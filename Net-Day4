------------------------------------------------------------------------------------------------------------------------
NETWORKING DAY 4 LINKS:
  STUDENT FG: https://net.cybbh.io/public/networking/latest/lesson-2-programming/fg.html
  SLIDES: https://net.cybbh.io/-/public/-/jobs/842494/artifacts/modules/networking/slides/2-Packet_Creation_and_Socket_Programming.html
  PYTHON REFERENCE LINKS:
    SOCKET: https://docs.python.org/3/library/socket.html
    STRUCT: https://docs.python.org/3/library/struct.html
    SYS: https://docs.python.org/3/library/sys.html
------------------------------------------------------------------------------------------------------------------------
GENERAL NOTES
SOCKET TYPES:
  USER SPACE SOCKETS:
    - MOST COMMON, CREATION DOES NOT REQUIRE ELEVATED PERMS AND TYPES ARE AS FOLLOWS:
    STREAM SOCKET - CONNECTION ORIENTED AND SEQUENCED; METHODS FOR CONNECTION ESTABLISHMENT AND TEAR-DOWN. USED WITH TCP, SCTP, AND BLUETOOTH
    DATAGRAM SOCKET - CONNECTIONLESS; DESIGNED FOR QUICKLY SENDING AND RECEIVING DATA. USED WITH UDP
  KERNEL SPACE SOCKETS:
    - DIRECT HARDWARE ACCESS ON BEHALF OF USER APP, REQUIRES ELEVATED PERMS AND ARE AS FOLLOWS:
    RAW SOCKET - DIRECT SENDING AND RECEIVING OF IP PACKETS WITHOUT AUTOMATIC PROTOCOL-SPECIFIC FORMATTING.
SOCKET CREATION IN PYTHON3:
  SYNTAX:
    import socket
    s = socket.socket(socket.FAMILY, socket.TYPE, socket.PROTOCOL)
    CONSTANTS:
      FAMILY: AF_INET (DEFAULT), AF_INET6, AF_UNIX
      TYPE: SOCK_STREAM (DEFAULT), SOCK_DGRAM, SOCK_RAW
      PROTO: 0 (DEFAULT), IPPROTO_RAW
  DEMO:
    vim stream.py
      #import socket
      #socket.function() SYNTAX
      #CREATE REFERENCEABLE LIBRARY ALIAS WITH: from socket as sock (from LIBRARY as ALIAS)
      #REFERENCE ONE FUNCTION IN LIBRARY WITHOUT IMPORTING THE WHOLE THING:
        #from socket import FUNCTION
        #function()
      #USE JUST FUNCTION NAMES RATHER THAN LIBRARY.FUNCTION REFERENCE SCHEME:
        from socket import * 
        function()
        functionEtc()
      import socket
      s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) CREATES SOCKET s WITH MOST SPECIFIC SYNTAX
      s = socket.socket CREATES SOCKET s USING DEFAULT CONSTANTS, SHORTER SYNTAX!
      ip = '127.0.0.1'
      port = 12345
      s.connect((ip, port))
      #PREFIX b TO STRING SENDS IT AS A BYTES-LIKE OBJECT. \n FOR NEWLINE
      s.send(b'Hello\n')
      #recvfrom BUFFERSIZE SHOULD BE POWER OF 2 AND NOT "TOO BIG"
      response, conn = s.recvfrom(1024)
      #BYTES-LIKE OBJECTS MUST BE DECODED INTO UTF-8 (DEFAULT)
      print.response.decode()
      s.close()
  DATAGRAM SOCKET DEMO:
    vim dgram.py
    import socket
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    ip = '127.0.0.1'
    port = 12345
    s.sendto(b'Hello\n', (ip,port))
    response, conn = s.recvfrom(1024)
    print(response.decode())
  RAW SOCKET DEMO:
  vim rawsock.py
    import socket FPR SOCKET BUILDING
    import sys FOR SYSTEM LEVEL COMMANDS
    from struct import * FOR PACKET STRUCTURE ESTABLISHMENT (DIRECT FUNCTION AND METHOD ACCESS)
    #CREATE RAW SOCKET BELOW:
      try:
        s = socket.socket(sock.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)
      except socket.error as msg:
        print(msg)
        sys.exit()
      packet = ''
      srcIp = "10.1.0.2"
      dstIp = "10.3.0.2"
      #ADD IPv4 HEADER INFO
      ipVerIHL = 69 #0x45 IN DECIMAL (FOR VERSION AND INTERNET HEADER LENGTH)
      ipTos = 0 #DSCP + ECN FIELD COMBO
      ipLen = 0 #KERNEL FILLS ACTUAL PACKET LENGTH
      ipId = 12345 #SETS PACKET IP ID 
      ipFrag = 0 #DISABLES IP FRAGMENTATION
      ipTtl = 64 #SETS PACKET TIME TO LIVE VALUE WHEN LEAVING MACHINE
      ipProto = 6 #SETS TCP PROTOCOL. VALUES TCP(6)/UDP(17) REQUIRE ADDITIONAL HEADERS AS SEEN BELOW!
      ipCheck = 0 #KERNEL FILLS IN PACKET CHECKSUM
      ipSrcAdd = socket.inet_aton(srcIp) #CONVERT SOURCE IP TO 32bit BINARY NUMBER
      ipDstAdd = socket.inet_aton(dstIp) #CONVERT DESTINATION IP TO 32bit BINARY NUMBER
      ipHeader = pack('!BBHHHBBH4s4s', ipVerIHL, ipTos, ipLen, ipId, ipFrag, ipTtl, ipProto, ipCheck, ipSrcAdd, ipDstAdd, ipHeader) #! LETS KERNEL KNOW DATA IS BEING SENT BIG ENDIAN, B=BYTES, H=HALF-WORD, 
      message = b'This is a message!'
      packet = ipHeader + message
      #SEND THE PACKET BELOW:
      s.sendto(packet, (dst_ip, 0))
RAW TCP SOCKETS DEMO:
cp rawsock.py tcpsock.py
vim tcpsock.py
  #DIRECTLY BELOW import sys IS AS FOLLOWS:
  import array
  #AFTER ipHeader (DELETE message AND BELOW):
    tcpSrc = 54321 #SOURCE PORT
    tcpDst = 7777 #DESTINATION PORT
    tcpSeq = 454 #SEQUENCE NUMBER
    tcpAckSeq = 0 #TCP ACK SEQUENCE NUMBER
    tcpDataOff = 5 #DATA OFFSET, SPECIFIES TCP HEADER SIZE IN 4-BYTE WORDS
    tcpReserve = 0 #3 RESERVE AND + ns FLAG IN RESERVE FIELD
    tcpFlags = 0 #TCP FLAGS FIELD (BEFORE BITS TURNED ON)
    tcpWin = 65535 #WINDOW SIZE MAX
    tcpChk = 0 #TCP CHECKSUM, CALCULATED LATER ON
    tcpUrgPtr = 0 #URGENT POINTER (ONLY IF urg FLAG SET)
    #COMBINE TCP OFFSET AND RESRVE FIELDS BY COMBINING LEFT SHIFTED 4 BITS TCP OFFSET AND RESERVE FIELD AS DONE BELOW:
    tcpOffRes = (tcpDataOff << 4) + tcpReserve #"<<" OPERATOR IS FOR BIT SHIFTING LEFT, ">>" SHIFTS BITS RIGHT
    #TCP FLAGS BY BIT STARTING FROM RIGHT TO LEFT BELOW:
    tcpFin = 0
    tcpSyn = 0
    tcpRst = 0
    tcpPsh = 0
    tcpAck = 0
    tcpUrg = 0
    tcpEce = 0
    tcpCwr = 0
    #COMBINE TCP FLAGS VIA LEFT SHIFTING BIT LOCATIONS, ADDING BITS TOGETHER BELOW:
    tcpFlags = tcpFin + (tcpSyn << 1) + (tcpRst << 2) + (tcpPsh << 3) + (tcpAck << 4) + (tcpUrg << 5) + (tcpEce << 6) + (tcpCwr << 7)
    # "!" IN PACK FORMAT STRING MEANS "NETWORK ORDER" AS SEEN BELOW:
    tcpHdr = pack('!HHLLBBHHH', tcpSrc, tcpDst, tcpSeq, tcpAckSeq, tcpOffRes, tcpFlags, tcpWin, tcpChk, tcpUrgPtr)
    usrData = n'Hello! Is this hidden?'
    #PSEUDO HEADER FIELDS BELOW:
    srcAddr = socket.inet_aton(srcIp)
    dstAddr = socket.inet_aton(dstIp)
    reserved = 0
    protocol = socket.IPPROTO_TCP
    tcpLen = len(tcpHdr) + lemn(usrData)
    #PACK PSEUDO HEADER AND COMBINE WITH USER DATA BELOW:
    psHdr = pack('!4s4sBBH', srcAddr, dstAddr, reserved, protocol, tcpLen)
    psHdr = psHdr + tcpHdr + usrData
    def checksum(data):
      if len(data) %2 != 0:
        data += b'\0'
      res = sum(array.array("H",data))
      res = (res >> 16) + (res & 0xffff) 
      res += res >> 16
      return (~res) & 0xffff # "~" (TILDE) CHARACTER "FLIPS THE BITS" OF WHATEVER VARIABLE ITS APPLIED TO
      tcpChk = checksum(psHdr)
      #PACK TCP HEADER TO FILL WITH CORRECT CHECKSUM - CHECKSUM IS NOT IN NETWORK BYTE ORDER BY DEFAULT!
      tcpHdr = pack('!HHLLBH', tcpSrc, tcpDst, tcpSeq, tcpAckSeq, tcpOffRes, tcpFlags, tcpWin) + pack('H', tcpChk) + pack('!H', tcpUrgPtr)
      #COMBINE ALL HEADERS AND USER DATA BELOW:
      packet = ipHdr + tcpHdr + usrData
      #SEND THE PACKET BELOW!
      s.sendto(packet, (dstIp, 0))
REQUIREMENTS:
    - MUST INCLUDE IP AND FOLLOW ON HEADERS
    - REQUIRES GUIDANCE FROM "REQUEST FOR COMMENTS" RFC TO FOLLOW HEADER STRUCTURE PROPERLY (SEE RFC 791 SECTION 3 FOR DIRECTIONS)
------------------------------------------------------------------------------------------------------------------------
CTFD CHALLENGES - 
